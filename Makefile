# pgcall package Makefile

SHELL         = /bin/bash
CFG           = .env
GO           ?= go
GOSOURCES    ?= $(shell find . -name "*.go")

sources_all  := $(wildcard *.go pgtype/*.go ginproc/*.go)
SOURCES      ?= $(filter-out %_mock_test.go,${sources_all})

# Dependencies
LINT          = $(shell command -v golangci-lint 2> /dev/null)

# Random id for test objects names
RANDOM_ID    ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)

# Postgresql Database image
PG_IMAGE     ?= postgres:11.4

PRG          ?= $(shell basename $$PWD)

# Postgresql variables
PGDATABASE   ?= $(PRG)
PGUSER       ?= $(PRG)
PGAPPNAME    ?= $(PRG)
PGHOST       ?= localhost
PGPORT       ?= 5472
PGSSLMODE    ?= disable
PGPASSWORD   ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)

# Postgresql container name
PG_CONTAINER  ?= dcape_db_1
# Postgresql container network
PG_NETWORK    ?= dcape_net

define CONFIG_DEFAULT
# ------------------------------------------------------------------------------
# pgcall config file, generated by make $(CFG)

# Database

# Host
PGHOST=$(PGHOST)
# Port
PGPORT=$(PGPORT)
# Name
PGDATABASE=$(PGDATABASE)
# User
PGUSER=$(PGUSER)
# Password
PGPASSWORD=$(PGPASSWORD)

endef
export CONFIG_DEFAULT

# ------------------------------------------------------------------------------

-include $(CFG)
export


.PHONY: help gen lint cov config linter-dep

##
## Available make targets
##

# default: show target list
all: help

# ------------------------------------------------------------------------------
## Sources

## Update generated mocks via github.com/golang/mock
gen:
	$(GO) generate

linter-dep:
ifeq ($(LINT),)
	$(error "linter is not available, please install it from https://github.com/golangci/golangci-lint")
else
	@echo "$(LINT) found."
endif

## Run linter
lint: linter-dep
	golangci-lint run $(GOSOURCES)

## Show coverage
cov: $(GOSOURCES)
	TZ="Europe/Berlin" \
	$(GO) test -coverprofile=coverage.txt -race -covermode=atomic -v ./...

test: cov

## Show coverage and update testdata files
cov-db-upd:
	TEST_UPDATE=yes \
	TZ="Europe/Berlin" \
	$(GO) test -coverprofile=coverage.out -race -covermode=atomic -tags=db -v ./...

## Show package coverage in html
cov-html:
	$(GO) tool cover -html=coverage.out

## Compare no-DB and DB tests coverage
cov-cmp:
	$(MAKE) -s cov-db
	@sort < coverage.out > coverage-db.out
	$(MAKE) -s cov
	@sort < coverage.txt > coverage-mock.out
	@diff -c0 coverage-mock.out coverage-db.out > coverage.diff && echo "No differences" || less coverage.diff

## Format go sources
fmt:
	$(GO) fmt ./lib/... && $(GO) fmt ./counter/... && $(GO) fmt ./cmd/...

## Run vet
vet:
	$(GO) vet -tags db *.go
	$(GO) vet pgtype/*.go
	$(GO) vet ginproc/*.go

# ------------------------------------------------------------------------------
# DB operations with docker and [dcape](https://github.com/dopos/dcape)

# (internal) Wait for postgresql container start
docker-wait:
	@echo -n "Checking PG is ready..."
	@until [[ `docker inspect -f "{{.State.Health.Status}}" $$PG_CONTAINER` == healthy ]] ; do sleep 1 ; echo -n "." ; done
	@echo "Ok"

## Create user, db and load dump
db-create: docker-wait
	@echo "*** $@ ***" ; \
	sql="CREATE USER \"$$PGUSER\" WITH PASSWORD '$$PGPASSWORD'" ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "$$sql" 2> >(grep -v "already exists" >&2) || true ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "CREATE DATABASE \"$$PGDATABASE\" OWNER \"$$PGUSER\";" 2> >(grep -v "already exists" >&2)

## Drop database and user
db-drop: docker-wait
	@echo "*** $@ ***"
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP DATABASE \"$$PGDATABASE\";" || true
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP USER \"$$PGUSER\";" || true

psql: docker-wait ## Run psql
	@docker exec -it $$PG_CONTAINER psql -U $$PGUSER -d $$PGDATABASE

## Run local psql
psql-local:
	@psql

# ------------------------------------------------------------------------------
## Misc

## Count lines of code (including tests) and update LOC.md
cloc: LOC.md

LOC.md: $(SOURCES)
	cloc --by-file --md $(SOURCES) > $@

# create initial config
$(CFG):
	@[ -f $@ ] || { echo "Creating default $@" ; echo "$$CONFIG_DEFAULT" > $@ ; }

## Create default config file
config:
	@true

## List Makefile targets
help:  Makefile
	@grep -A1 "^##" $< | grep -vE '^--$$' | sed -E '/^##/{N;s/^## (.+)\n(.+):(.*)/\t\2:\1/}' | column -t -s ':'
