# pgcall package Makefile

SHELL       = /bin/bash
CFG         = .env
GO         ?= go
SOURCES    ?= *.go *-pgcall/*.go
GOSOURCES  ?= ./... ./pgx-pgcall/... ./gin-pgcall/...

CODECOV_KEY =

# Random id for test objects names
RUN_ID             ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)

# Postgresql Database image
PG_IMAGE         ?= postgres:11.1

PG_PORT_LOCAL    ?=

#DB_PASS            ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)

define CONFIG_DEF
# ------------------------------------------------------------------------------
# pgcall config file, generated by make $(CFG)

# Random id for test objects names
RUN_ID=$(RUN_ID)

# codecov.io API key
CODECOV_KEY=$(CODECOV_KEY)
endef
export CONFIG_DEF

# ------------------------------------------------------------------------------

-include $(CFG)
export

# ------------------------------------------------------------------------------

## run linter
lint:
	golangci-lint run $(GOSOURCES)

# ------------------------------------------------------------------------------

## Show coverage
cov:
	$(GO) generate
	$(GO) test -coverprofile=coverage.out -race -covermode=atomic -v $(GOSOURCES)

## Show coverage
cov-db:
	if [[ ! "$(PG_PORT_LOCAL)" ]] ; then  \
	PG_PORT_LOCAL=$(shell docker inspect "test-pgfc-$(RUN_ID)" --format '{{ index (index (index .NetworkSettings.Ports "5432/tcp") 0) "HostPort" }}') ; \
	fi
	DB_SCHEMA="pgfc_test,public" DB_LOGLEVEL=debug \
	PGHOST=localhost PGPORT=$$PG_PORT_LOCAL PGDATABASE=pgfc_$$RUN_ID \
	PGUSER=postgres PGPASSWORD=$$RUN_ID PGAPPNAME=pgfc \
	$(GO) test -coverprofile=coverage.out -race -covermode=atomic -tags="db nocommon" -v $(GOSOURCES)

## Show package coverage in html
cov-html:
	$(GO) tool cover -html=coverage.out

cov-cmp:
	$(MAKE) -s cov-db
	@sort < coverage.out > coverage-db.out
	$(MAKE) -s cov
	@sort < coverage.out > coverage-mock.out
	@diff -c0 coverage-mock.out coverage-db.out > coverage.diff &&  echo "No differences" || less coverage.diff

## Format go sources
fmt:
	$(GO) fmt ./lib/... && $(GO) fmt ./counter/... && $(GO) fmt ./cmd/...

## Run vet
vet:
	$(GO) vet *.go
	$(GO) vet pgx-pgcall/*.go
	$(GO) vet gin-pgcall/*.go

# ------------------------------------------------------------------------------

# Run tests when postgresql is available
test-db-exists:

# ------------------------------------------------------------------------------
# Run tests with docker

# find unused local port
# https://unix.stackexchange.com/questions/55913/whats-the-easiest-way-to-find-an-unused-local-port
# https://unix.stackexchange.com/a/248319
find-port:
	@if [[ ! "$(PG_PORT_LOCAL)" ]] ; then  \
	read LOWERPORT UPPERPORT < /proc/sys/net/ipv4/ip_local_port_range ; \
	while true ; do  \
	PG_PORT_LOCAL="`shuf -i $$LOWERPORT-$$UPPERPORT -n 1`" ; \
	ss -lpn | grep -q ":$$PORT " || break ; \
	done ; \
	fi ; \
	echo $$PG_PORT_LOCAL

# Start postgresql via docker
test-docker-run: find-port
	docker run --rm --name test-pgfc-$$RUN_ID \
	-p "127.0.0.1:$$PG_PORT_LOCAL:5432" \
	-e POSTGRES_PASSWORD=$$RUN_ID \
	-e POSTGRES_DB=pgfc_$$RUN_ID \
	-e WORKDIR=/docker-entrypoint-initdb.d \
	-v $(shell pwd)/tmp-db:/var/lib/postgresql/data \
	-v $(shell pwd)/testdata:/docker-entrypoint-initdb.d $$PG_IMAGE

psql:
	@docker exec -it test-pgfc-$$RUN_ID psql -U postgres -d pgfc_$$RUN_ID

# Stop postgresql via docker
test-docker-stop:
	docker stop test-pgfc-$(RUN_ID)

# ------------------------------------------------------------------------------

## create initial config
$(CFG):
	@[ -f $@ ] || { echo "$$CONFIG_DEF" > $@ ; echo "Warning: Created default $@" ; }

# ------------------------------------------------------------------------------

## List Makefile targets
help:
	@grep -A 1 "^##" Makefile | less

##
## Press 'q' for exit
##
