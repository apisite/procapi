# pgfc package Makefile

SHELL               = /bin/bash
CFG               = .env
CFG_BAK          ?= $(CFG).bak

GO            ?= go

# Random id for test objects names
RUN_ID             ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)
#RUN_ID = 000

# Postgresql Database image
PG_IMAGE         ?= postgres:11.1

PG_PORT_LOCAL    ?=

#DB_PASS            ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)

define CONFIG_DEF
# ------------------------------------------------------------------------------
# pgfc config file, generated by make $(CFG)

# Random id for test objects names
RUN_ID=$(RUN_ID)
endef
export CONFIG_DEF

# ------------------------------------------------------------------------------

# if exists - load old values
-include $(CFG_BAK)
export

-include $(CFG)
export

#	PGFC_CONNECT="postgres:$$RUN_ID@localhost:32794/pgfc_$$RUN_ID?sslmode=disable" \

## Show coverage
coverage:
	$(GO) generate
	GO111MODULE11=off $(GO) test -coverprofile=coverage.out -v ./...

## Show coverage
coverage-db:
	PG_PORT_LOCAL=$(shell docker inspect "test-pgfc-$(RUN_ID)" --format '{{ index (index (index .NetworkSettings.Ports "5432/tcp") 0) "HostPort" }}') \
	DB_SCHEMA="pgfc_test,public" DB_DEBUG=false \
	PGHOST=localhost PGPORT=$$PG_PORT_LOCAL PGDATABASE=pgfc_$$RUN_ID \
	PGUSER=postgres PGPASSWORD=$$RUN_ID PGAPPNAME=pgfc \
	$(GO) test -coverprofile=coverage.out -tags=db -v

## Show package coverage in html (make cov-html PKG=counter)
cov-html:
	$(GO) tool cover -html=coverage.out

cmp-coverage:
	$(MAKE) -s coverage-db
	sort < coverage.out > coverage-db.out
	$(MAKE) -s coverage
	sort < coverage.out > coverages.out
	diff -c0 coverages.out coverage-db.out > coverage.diff || less coverage.diff

## Run lint
lint:
	golint ./...

## Format go sources
fmt:
	$(GO) fmt ./lib/... && $(GO) fmt ./counter/... && $(GO) fmt ./cmd/...

## Run vet
vet:
	$(GO) vet *.go pgxi/*.go

# ------------------------------------------------------------------------------

# Run tests when postgresql is available
test-db-exists:

# ------------------------------------------------------------------------------
# Run tests with docker

# find unused local port
# https://unix.stackexchange.com/questions/55913/whats-the-easiest-way-to-find-an-unused-local-port
# https://unix.stackexchange.com/a/248319
find-port:
	@read LOWERPORT UPPERPORT < /proc/sys/net/ipv4/ip_local_port_range ; \
	while true ; do  \
	PG_PORT_LOCAL="`shuf -i $$LOWERPORT-$$UPPERPORT -n 1`" ; \
	ss -lpn | grep -q ":$$PORT " || break ; \
	done

# Start postgresql via docker
test-docker-run: find-port
	docker run --rm --name test-pgfc-$$RUN_ID \
	-p "127.0.0.1:$$PG_PORT_LOCAL:5432" \
	-e POSTGRES_PASSWORD=$$RUN_ID \
	-e POSTGRES_DB=pgfc_$$RUN_ID \
	-e WORKDIR=/docker-entrypoint-initdb.d \
	-v $(shell pwd)/testdata:/docker-entrypoint-initdb.d $$PG_IMAGE

#	-v $(shell pwd)/t/initdb:/docker-entrypoint-initdb.d $$PG_IMAGE

#go run main.go --db_connect 'postgres:UHFbuj0lZSpED6@localhost:32793/pgfc_UHFbuj0lZSpED6?sslmode=disable' --db_schema 'pgfc_uhfbuj0lzsped6,public'

#  PGFC_CONNECT='postgres:UHFbuj0lZSpED6@localhost:32793/pgfc_UHFbuj0lZSpED6?sslmode=disable' DB_SCHEMA='pgfc_uhfbuj0lzsped6,public' go test

# Stop postgresql via docker
test-docker-stop:
	docker stop test-pgfc-$(RUN_ID)

# ------------------------------------------------------------------------------

## create initial config
$(CFG):
	@[ -f $@ ] || { echo "$$CONFIG_DEF" > $@ ; echo "Warning: Created default $@" ; }

# ------------------------------------------------------------------------------

## List Makefile targets
help:
	@grep -A 1 "^##" Makefile | less

##
## Press 'q' for exit
##
